use anyhow::{Context, Result, bail};
use std::fs;
use std::path::{Path, PathBuf};
use syn::{Attribute, ItemEnum, Lit};
use walkdir::WalkDir;

fn main() -> Result<()> {
    let args: Vec<String> = std::env::args().collect();

    match args.get(1).map(String::as_str) {
        Some("gen-error-index") => gen_error_index(),
        _ => {
            eprintln!("Usage: cargo run -p xtask -- gen-error-index");
            std::process::exit(1);
        }
    }
}

fn gen_error_index() -> Result<()> {
    let root = workspace_root()?;
    let lib_src = root.join("engines/yonasBSD/models/model-A/features/generator/packages/lib/src");

    let mut errors = Vec::new();

    for entry in WalkDir::new(&lib_src)
        .into_iter()
        .filter_map(Result::ok)
        .filter(|e| e.path().extension().and_then(|s| s.to_str()) == Some("rs"))
    {
        let path = entry.path();
        let content =
            fs::read_to_string(path).with_context(|| format!("reading {}", path.display()))?;

        let file =
            syn::parse_file(&content).with_context(|| format!("parsing {}", path.display()))?;

        for item in file.items {
            if let syn::Item::Enum(e) = item {
                if e.ident == "EngineError" {
                    errors.extend(extract_error_variants(&e, path)?);
                }
            }
        }
    }

    validate_errors(&errors)?;

    let index = render_markdown(&errors);

    let assets_dir =
        root.join("engines/yonasBSD/models/model-A/features/generator/packages/main/assets");
    fs::create_dir_all(&assets_dir)?;
    let out_path = assets_dir.join("error-index.md");
    fs::write(&out_path, index)?;

    println!("Generated {}", out_path.display());
    Ok(())
}

#[derive(Debug, Clone)]
struct ErrorDoc {
    code: String,
    name: String,
    docs: String,
    file: PathBuf,
}

fn extract_error_variants(e: &ItemEnum, file: &Path) -> Result<Vec<ErrorDoc>> {
    let mut out = Vec::new();

    for variant in &e.variants {
        let code = find_diagnostic_code(&variant.attrs)?;
        if let Some(code) = code {
            let docs = collect_doc_comments(&variant.attrs);
            if docs.trim().is_empty() {
                bail!(
                    "Error variant {} in {} has code {} but no docs",
                    variant.ident,
                    file.display(),
                    code
                );
            }

            out.push(ErrorDoc {
                code,
                name: variant.ident.to_string(),
                docs,
                file: file.to_path_buf(),
            });
        }
    }

    Ok(out)
}

fn find_diagnostic_code(attrs: &[Attribute]) -> Result<Option<String>> {
    for attr in attrs {
        if attr.path().is_ident("diagnostic") {
            let mut found: Option<String> = None;

            attr.parse_nested_meta(|meta| {
                if meta.path.is_ident("code") {
                    let value: Lit = meta.value()?.parse()?;
                    if let Lit::Str(s) = value {
                        found = Some(s.value());
                    }
                }
                Ok(())
            })?;

            if found.is_some() {
                return Ok(found);
            }
        }
    }
    Ok(None)
}

fn collect_doc_comments(attrs: &[Attribute]) -> String {
    let mut docs = String::new();

    for attr in attrs {
        if attr.path().is_ident("doc") {
            if let Ok(meta) = attr.meta.require_name_value() {
                let value = &meta.value;

                // syn 2: doc comments are Expr::Lit(Lit::Str)
                if let syn::Expr::Lit(expr_lit) = value {
                    if let Lit::Str(s) = &expr_lit.lit {
                        docs.push_str(&s.value());
                        docs.push('\n');
                    }
                }
            }
        }
    }

    docs
}

fn validate_errors(errors: &[ErrorDoc]) -> Result<()> {
    use std::collections::HashMap;

    let mut seen = HashMap::new();

    for e in errors {
        if let Some(prev) = seen.insert(e.code.clone(), e) {
            bail!(
                "Duplicate error code {}:\n  {}\n  {}",
                e.code,
                prev.file.display(),
                e.file.display()
            );
        }
    }

    Ok(())
}

fn render_markdown(errors: &[ErrorDoc]) -> String {
    let mut out = String::new();

    out.push_str("# Engine.rs Error Index\n\n");
    out.push_str(
        "This document is generated by `cargo run -p xtask -- gen-error-index`.\n\n---\n\n",
    );

    let mut sorted = errors.to_vec();
    sorted.sort_by(|a, b| a.code.cmp(&b.code));

    for e in sorted {
        out.push_str(&format!("## {}: {}\n\n", e.code, e.name));
        out.push_str(&e.docs);
        out.push('\n');

        // NEW: merge sidecar file
        if let Some(extra) = load_sidecar(&e.code) {
            out.push_str(&extra);
            out.push('\n');
        }

        out.push_str("\n---\n\n");
    }

    out
}

fn load_sidecar(code: &str) -> Option<String> {
    let lib_root = find_crate_root("engine-rs-lib").ok()?;
    let path = lib_root.join("errors").join(format!("{code}.md"));
    std::fs::read_to_string(path).ok()
}

fn find_crate_root(crate_name: &str) -> Result<PathBuf> {
    let metadata = cargo_metadata::MetadataCommand::new()
        .no_deps()
        .exec()
        .context("running cargo metadata")?;

    for pkg in metadata.packages {
        if pkg.name == crate_name {
            let manifest_dir = pkg
                .manifest_path
                .parent()
                .expect("manifest has no parent")
                .to_path_buf();

            return Ok(manifest_dir.into());
        }
    }

    bail!("crate `{crate_name}` not found in workspace");
}

fn workspace_root() -> Result<PathBuf> {
    let out = std::process::Command::new("cargo")
        .args(["metadata", "--format-version=1", "--no-deps"])
        .output()
        .context("running cargo metadata")?;

    if !out.status.success() {
        bail!("cargo metadata failed");
    }

    let v: serde_json::Value = serde_json::from_slice(&out.stdout)?;
    let root = v["workspace_root"]
        .as_str()
        .context("missing workspace_root")?;
    Ok(PathBuf::from(root))
}
